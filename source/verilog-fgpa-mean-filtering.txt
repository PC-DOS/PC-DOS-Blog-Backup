需求：编写一个内存控制器，从上游接收双通道、每通道16位的正交I-Q信号对，进行均值滤波后，形成数据帧并存入FIFO，并将低电平有效的数据有效中断拉低一段时间，供后续数据流使用。均值滤波的目的在于将上游传来的高帧率数据进行帧合并，从而降低对下游模块实时性的要求。

 最初的计划实现是：

1. 电路包含主控制逻辑、字长16 bit的片载块内存（使用BRAM块内存IP实现）和字长16 bit的输出FIFO。主控制逻辑使用三段式有限状态机（FSM）完成状态更新、状态转移表和功能执行。并使用一系列常量定义了块内存和FIFO的操作时序。

 块内存和FIFO使用以下策略存储数据：

||~ 地址{{ADDR}} || {{0x0000}} || {{0x0001}} || {{0x0002}} || {{0x0003}} || ... || {{2n-2}} || {{2n-1}} ||
 ||~ 数据{{DATA}} || 数据点1 - I路信号 || 数据点1 - Q路信号 || 数据点2 - I路信号 || 数据点2 - Q路信号 || ... || 数据点n - I路信号 || 数据点n - Q路信号 ||

2. 主控制逻辑包括一个帧计数器，记录当前已存入块内存的帧计数。主控制器依照下列顺序轮转：

2.1 接收到上游数据有效信号后，锁存输入的I、Q两路信号，进入IO时序。IO时序期间到达的数据点将被抛弃，由丢帧逻辑处理丢帧事务。

2.2 设置块内存读使能引脚有效，使用计数器打拍延迟，从块内存读取输出端口读取块内存当前地址的数据。

2.3 使用下面的公式进行均值滤波：

[[code]]
滤波后数据 = (块内存当前数据 * 已存入块内存的帧计数 + 当前数据) / (已存入块内存的帧计数 + 1)
 [[/code]]

 2.4 检查当前已存入块内存的帧计数加一（计入当前正在处理的帧）是否已达到输出阈值，若是，则设置相应标志，表示需要将当前数据转移到FIFO中。

2.5 停止块内存读使能，判断是否需要转移当前数据到FIFO。

2.5.1 若是，则将当前数据推入FIFO的数据输入端，设置FIFO写使能引脚有效，计数器打拍延迟一段时间后取消使能，完成FIFO写。同时，将块内存数据输入端口置0。进入块内存数据写入流程。

2.5.2 若不是，则直接进入块内存数据写入流程。

2.6 设置块内存使能和写使能引脚有效，使用计数器打拍延迟，将平滑滤波后的数据写入内存。

2.7 停止块内存写使能，更新块内存操作地址计数器（地址指针），读取锁存的Q路信号数据，进入Q路信号数据处理流程。

2.8 重复步骤2.2到步骤2.6，完成Q路信号的操作。

2.9 停止块内存写使能，更新块内存操作地址计数器（地址指针），同时依照下列顺序执行判断：

2.9.1 若当前地址指针已达到一个数据帧的末尾，则更新地址指针为0（返回块内存头部），并将帧计数器加一。

2.9.2 若帧计数器已达到输出阈值，则将帧计数器置0，同时设置数据有效中断重置标志位。一个独立的时序电路被激活，并以特定的时序设置数据有效中断引脚上的电平。

 实际工作时，发现平滑滤波步骤原始的算法会引入一个DSP乘法器，和一系列除法运算逻辑或除法器IP，从而导致整个系统的延时和时序无法收敛。从而做出以下更改：

1. 块内存的字长扩展到32 bit。同时规定平滑滤波和帧合并所用的帧数必须为2的整数次幂。

2. 步骤2.3中，仅将当前数据累加到块内存输出端口上的数据上，即不进行任何乘除法运算，块内存内仅存放所有缓存的帧在当前索引上的数据的和。

3. 步骤2.5.1中，将数据推入FIFO的数据输入端前，执行一次右移运算，将数据右移平滑滤波和帧合并所用的帧数对2的对数个位数。

 随后，为了提升系统的可维护性，降低模块之间的耦合，并将均值滤波缓冲区的I/O和FIFO的I/O异步化，做出以下修改：

1. 将整个模块拆分为独立的均值滤波模块和FIFO控制器。两个模块之间通过数据总线和一个“数据准备好”通知引脚连接。

2. 将步骤2.4修改为：检查当前已存入块内存的帧计数加一（计入当前正在处理的帧）是否已达到输出阈值，若是，则设置相应标志，表示需要将当前数据转移到下游数据流或缓冲区中。

3. 在步骤2.5修改为：停止块内存读使能，判断是否需要转移当前数据到FIFO。若是，则设置标志位，由独立的定时电路将“数据准备好”通知引脚拉高一段时间，下游FIFO控制器检测到“数据准备好”通知引脚高电平后，独立异步地完成数据的锁存和FIFO写入，同时，将块内存数据输入端口置0。进入块内存数据写入流程。否则，直接进入块内存数据写入流程。

 由此，将均值滤波和下游电路的工作异步化，实现中，FIFO的写入工作不再会阻塞I-Q两路信号对的均值滤波和缓冲区操作。

 同时需要注意的是，由于整个系统运行时存在对输入数据的等待等行为，因此系统所用的FSM近似于Mealy状态机，故在三段式写法下，用于判断当前状态并执行相应功能的代码段只能对当前状态寄存器做判断，而不能对后继状态寄存器做判断，否则将在综合后时序仿真时出现异常以及寄存器建立-保持时间告警。 