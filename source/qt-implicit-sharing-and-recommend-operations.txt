Qt的容器类（以及一些容器类的派生类和Qt库内部类）使用隐式共享（Implicit Sharing）机制，以提升性能。这个机制保证复制Qt容器类以及许多内部类（包括{{QVector< T >}}、{{QLinkedList< T >}}、{{QList< T >}}、{{QStringList}}、{{QStack< T >}}、{{QQueue< T >}}、{{QMap< K , T >}}、{{QMultiMap< K , T >}}、{{QHash< K , T >}}、{{QMultiHash< K , T >}}、{{QString}}、{{QByteArray}}、{{QVariant}}、{{QBrush}}、{{QFont}}等）对象时，优先执行一个浅复制（影复制，可以简单理解为仅复制指向容器的指针），只有复制项发生改变时，才执行完全复制（深复制）。

Qt隐式共享机制的实现基础是{{QSharedData}}和{{QSharedDataPointer}}类。

为了利用隐式共享机制带来的在性能以及代码可读性方面的优化，推荐的工作流程包括：

* 对于需要返回支持隐式共享机制的对象的函数，直接将该函数的返回类型设为这个对象的类型，而不再使用修改引用型参数的方法进行返回。
* 只读访问非常量的向量（{{Vector}}）或列表（{{List}}）时，使用{{at()}}函数，而非{{[]}}操作符[[footnote]]Qt无法判断{{[]}}操作符的使用目的（读取/赋值），因此会在使用{{[]}}操作符时执行深复制。而{{at()}}函数只允许进行读操作。[[/footnote]]。
* 只读访问非常量的键值对容器（关联容器，字典型容器，如{{QMap< K , T >}}、{{QMultiMap< K , T >}}、{{QHash< K , T >}}、{{QMultiHash< K , T >}}等）的值时，使用{{value()}}函数，而非{{[]}}操作符[[footnote]]Qt无法判断{{[]}}操作符的使用目的（读取/赋值），因此会在使用{{[]}}操作符时执行深复制，且{{[]}}操作符的使用可能导致非预期的空值的创建。而{{value()}}函数只允许进行读操作，不进行深复制，亦不会导致未预期的空值的形成。[[/footnote]]。
* 使用STL风格的迭代器{{C<T>::iterator}}时，对{{begin()}}和{{end()}}函数的调用也会导致深复制。推荐的操作包括：
 * 使用返回常量的STL风格迭代器{{C<T>::const_iterator}}代替{{C<T>::iterator}}。
 * 使用{{begin()}}和{{end()}}函数的常量版本{{constBegin()}}和{{constEnd()}}。

@@@@
@@@@
@@@@
@@@@
@@@@

参考资料：//Jasmin Blanchette,Mark Summerfield.C++ GUI Qt4编程（第二版）[M].闫峰新,曾泉人,张志强,等译.电子工业出版社:北京,2018//

需要注意的是，由于{{at()}}、{{value()}}函数返回的是**请求的数据的副本**，而{{[]}}操作符返回的是**请求的数据的引用**，因此，当您的程序对性能敏感，且包含大量的读取操作时，使用{{[]}}操作符可能更为经济。 