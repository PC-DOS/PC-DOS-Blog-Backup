[*https://pyrates.readthedocs.io/en/latest/basic_info.html PyRates]是一个基于神经元放电率的神经动力学仿真库，使用该库可以实现基于[*https://link.springer.com/article/10.1007/BF00199471 Jansen-Rit模型]的神经动力学模型建模。

+ PyRates的安装

PyRates可以使用`pip`命令进行安装：

[[code]]
pip install pyrates
[[/code]]

在Python代码文件中，引入{{pyrates}}包即可使用PyRates：

[[code type="python"]]
import pyrates
[[/code]]

+ 基本结构

Jansen-Rit模型环路（Circuit）中的每个环路节点包含3个子节点：
* 兴奋性神经元（excitatory interneurons, EIN）
* 抑制性神经元（inhibitory interneurons, IIN）
* 锥体细胞（Pyramidal cells, PC）

在PyRates中，每个子节点被描述为一系列“算子（Operator）”的集合，包括：
* 放电率-电位算子（Rate-to-potential operator, RPO）：将放电率转化为可测量的组织电位
* 电位-放电率算子（Potential-to-rate operator, PRO）：将组织电位转换为放电率

通常，EIN和IIN只包含RPO和PRO各一个，而PC则包含2个RPO（分别接受来自EIN和IIN的输出）和1个PRO。

EIN、IIN和PC构成一个环路节点，环路节点之间通过“边（Edge）”连接。

因此，在一个Jansen-Rit模型中，存在以下信息流（假设输入到PC的外部输入为Vi）：
* EIN：(前级输出+PC输出) → EIN兴奋性RPO → 电压 → PRO → PC兴奋性RPO → V1
* IIN：(前级输出+PC输出) → IIN兴奋性RPO → 电压 → PRO → PC抑制性RPO → V2
* PC：(V1+V2+Vi) → 电压 → PRO → PC输出（后级输入）

PyRates也支持通过YAML描述文件定义模型。可以参考随PyRates一同安装的{{model_templates}}包的{{neural_mass_models/jansenrit.yaml}}文件。

+ 定义算子

PyRates将算子描述为{{pyrates.frontend.OperatorTemplate}}对象的实例，该对象通过{{equations}}属性定义其内部的数学方程组，并使用{{variables}}属性定义方程组中变量或常量的含义（如输入量{{@@"input"@@}}、输出量{{@@"output"@@}}、临时变量{{@@"variable"@@}}或具有固定数值的常量等，其中输出量有且仅能有1个）。

定义变量时，不能使用某些名称或后缀，因为它们为PyRates内部保留或预定义的符号，该非法符号列表由{{pyrates.frontend.OperatorTemplate.check_vname()}}函数定义：

[[code type="python"]]
disallowed_names = ['y', 'dy', 'source_idx', 'target_idx', 'pi', 'I', 'E']
disallowed_name_parts = ['_buffer', '_delays', '_maxdelay', '_idx', '_hist']
[[/code]]

下面的方法可以用来定义兴奋性RPO（RPO_e）、抑制性RPO（RPO_i）和PRO的模板对象，从而避免反复定义算子方程组和变量：

[[code type="python"]]
import pyrates
from pyrates.frontend import OperatorTemplate, NodeTemplate, EdgeTemplate, CircuitTemplate

# String constants
# Operators
sRPEDescTemplate = "Excitatory rate-to-potential operator"
sRPIDescTemplate = "Inhibitory rate-to-potential operator"
sPRODescTemplate = "Sigmoidal potential-to-rate operator"
# Sub nodes
sEINDescTemplate = "Excitatory interneurons (EIN)"
sIINDescTemplate = "Inhibitory interneurons (IIN)"
sPMCDescTemplate = "Pyramidal cells (PC)"
# Jansen-Rit circuits
sJRCDescTemplate = "Jansen-Rit circuit model"

# Operator templates
# Use copy.deepcopy() to create replica of these operator templates for your own nodes
rpeTemplate = OperatorTemplate(name="RPO_e", path=None,
    equations=[
        "d/dt * V = I_c",
        "d/dt * I_c = H/tau * m_in - 2 * I_c/tau - V/(tau^2)"
        ],
    variables={
        "V" : "output",
        "I_c" : "variable",
        "m_in" : "input",
        "tau" : 0.01,
        "H" : 0.00325,
    },
    description=f"{sRPEDescTemplate} template")
rpiTemplate = OperatorTemplate(name="RPO_i", path=None,
    equations=[
        "d/dt * V = I_c",
        "d/dt * I_c = H/tau * m_in - 2 * I_c/tau - V/(tau^2)"
        ],
    variables={
        "V" : "output",
        "I_c" : "variable",
        "m_in" : "input",
        "tau" : 0.02,
        "H" : -0.022,
    },
    description=f"{sRPIDescTemplate} template")
proTemplate = OperatorTemplate(name="PRO", path=None, 
    equations=["m_out = 2*m_max / (1 + exp(r * (V_thr - V)))"],
    variables={
        "m_out" : "output",
        "V" : "input",
        "V_thr" : 6e-3,
        "m_max" : 2.5,
        "r" : 560.0
    },
    description=f"{sPRODescTemplate} template")
[[/code]]

使用{{copy.deepcopy()}}建立算子实例的深拷贝对象，PyRates的{{Template}}类提供了用于修改对象参数的{{update_template()}}接口：

[[code type="python"]]
import copy

sCurrentNodeName = "Demo Jansen-Rit Circuit (DemoJRC)"
# Operators
rpeDemoJRC = copy.deepcopy(rpeTemplate).update_template(name="RPO_e", path=None,
    description=f"{sRPEDescTemplate} of {sCurrentNodeName}")
rpiDemoJRC = copy.deepcopy(rpiTemplate).update_template(name="RPO_i", path=None,
    description=f"{sRPIDescTemplate} of {sCurrentNodeName}")
proDemoJRC = copy.deepcopy(proTemplate).update_template(name="PRO", path=None, 
    description=f"{sPRODescTemplate} of {sCurrentNodeName}")
[[/code]]

+ 定义子节点

PyRates将子节点描述为{{pyrates.frontend.NodeTemplate}}对象的实例，该对象通过{{operators}}属性定义其使用的算子列表）。

[[code type="python"]]
# Sub nodes
einDemoJRC = NodeTemplate(name="EIN", path=None, operators=[rpeDemoJRC, proDemoJRC],
    description=f"{sEINDescTemplate} of {sCurrentNodeName}")
iinDemoJRC = NodeTemplate(name="IIN", path=None, operators=[rpeDemoJRC, proDemoJRC],
    description=f"{sIINDescTemplate} of {sCurrentNodeName}")
pmcDemoJRC = NodeTemplate(name="PC", path=None, operators=[rpeDemoJRC, rpiDemoJRC, proDemoJRC],
    description=f"{sPMCDescTemplate} of {sCurrentNodeName}")
[[/code]]

+ 定义环路节点

PyRates将环路节点描述为{{pyrates.frontend.CircuitTemplate}}对象的实例，该对象使用{{nodes}}属性定义节点中的子节点，使用{{circuits}}属性定义子环路，并使用{{edges}}属性定义环路中各边的起止点和权重等参数。

其中，{{nodes}}和{{circuits}}属性使用键值对的形式，定义子节点名称和对象实例之间的对应关系。{{edges}}属性使用{{pyrates.frontend.CircuitTemplate}}对象中子节点及算子的{{name}}和{{variables}}属性，确定该边从何输出变量获取数据，并传送到何输入变量，使用“环路/节点/算子/变量”格式定义。{{edges}}属性的最后一个字段描述了该边的性质，包括{{weight}}（权重）、{{delay}}（时延）、{{spread}}（扩散）等。

[[code type="python"]]
# Sub node interconnections in Jansen-Rit Model
jrcDemoJRCNode1 = CircuitTemplate(name="JRC_DemoJRCNode", path=None,
    nodes={
        "EIN" : einDemoJRC,
        "IIN" : iinDemoJRC,
        "PC" : pmcDemoJRC
    },
    edges=[
        # EIN -> PC
        ("EIN/PRO/m_out", "PC/RPO_e/m_in", None, {"weight" : 108, "delay" : 0.0, "spread" : 0.0}),
        # IIN -> PC
        ("IIN/PRO/m_out", "PC/RPO_i/m_in", None, {"weight" : 33.75, "delay" : 0.0, "spread" : 0.0}),
        # PC -> EIN
        ("PC/PRO/m_out", "EIN/RPO_e/m_in", None, {"weight" : 135, "delay" : 0.0, "spread" : 0.0}),
        # PC -> IIN
        ("PC/PRO/m_out", "IIN/RPO_e/m_in", None, {"weight" : 33.75, "delay" : 0.0, "spread" : 0.0}),
    ],
    description=f"{sJRCDescTemplate} of {sCurrentNodeName}")
jrcDemoJRCNode2 = copy.deepcopy(jrcDemoJRCNode1)

# Circuit with 2 Jansen-Rit circuits
jrcDemoJRC = CircuitTemplate(name="JRC_DemoJRC", path=None,
    circuits={
        "JRC1" : jrcDemoJRCNode1,
        "JRC2" : jrcDemoJRCNode2
    },
    edges=[
        # Signals from other brain regions are inputted to PC
        # JRC1 -> JRC2, excitatory
        ("JRC1/PC/PRO/m_out", "JRC2/PC/RPO_e/m_in", None, {"weight" : 20.0, "delay" : 0.004, "spread" : 0.001}),
        # JRC2 -> JRC1, excitatory
        ("JRC2/PC/PRO/m_out", "JRC1/PC/RPO_e/m_in", None, {"weight" : 40.0, "delay" : 0.004, "spread" : 0.001}),
    ],
    description=f"{sJRCDescTemplate} of {sCurrentNodeName}")
[[/code]]

已经定义的{{pyrates.frontend.CircuitTemplate}}对象实例可以通过{{pyrates.frontend.CircuitTemplate.update_var()}}函数更新参数。该函数接收{{node_vars}}和{{edge_vars}}等2个参数，描述对节点内部变量和边信息的更新：
* {{node_vars}}为字典（键值对），其键名使用“环路/节点/算子/变量”格式指明目标，值为目标变量的新值。
* {{edge_vars}}为一个由三元组组成的列表，每个三元组的第一个元素使用“环路/节点/算子/变量”格式指明该边起点，第二个元素使用“环路/节点/算子/变量”格式指明该边终点，第三个元素为描述该边参数的键值对。

+ 开始仿真

使用{{pyrates.frontend.CircuitTemplate}}对象的{{run()}}函数开始仿真，该函数的常用参数包括：
* {{simulation_time}}：仿真时长，单位为秒。
* {{step_size}}：仿真步长，单位为秒。
* {{sapling_step_size}}：采样步长，单位为秒。
* {{outputs}}：仿真输出键值对，键名为仿真输出（虚拟采样通道）的索引名称，值为{{pyrates.frontend.CircuitTemplate}}对象中子节点及算子的{{name}}和{{variables}}属性确定的输出名称，表示记录来自哪个变量的数据。注意：只有输出变量（类型为“{{output}}”的变量）可被测量。
* {{inputs}}：输入键值对，键名为{{pyrates.frontend.CircuitTemplate}}对象中子节点及算子的{{name}}和{{variables}}属性确定的输入名称，表示向哪个变量输入数据。值为预先生成的输入信号（一维数组），输入信号的采样间隔应与仿真步长一致（即输入信号数组的长度应为仿真时长除以仿真步长）。

[[code type="python"]]
import numpy as np
import scipy

dSimulationDuration = 5.0
dSimulationStep = 1e-4
dSamplingStep = 1.0 / 500.0
dSimulationPaddingAtStart = 0.0

# Calculate real simulation duration
# PyRates outputs simulation_time*(1.0/sampling_step_size) points after simulation
# Thus the real timespan (MNE algorithm) is simulation_time-dSamplingStep seconds
# To fix this, you can add 1 sampling_step_size to simulation_time.
# dSimulationPaddingAtStart is adopted to contain unstable leading segment
dSimulationDurationReal = dSimulationPaddingAtStart + dSimulationDuration + dSamplingStep

# Generate input signal (square wave)
# Square wave is generated using scipy.signal.square()
# Note that scipy.signal.square() generates a square wave with a period of 2*pi and a range of [-1, 1]
# See https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.square.html#scipy.signal.square
# In this demo, we generated a signal with 130 Hz frequency and 10% cycle duty, in the range of [0, 5]
dInputSignalAmplitude=2.5
dInputSignalFreq=130
dInputSignalPhase=0.0
dInputSignalDuty=0.1
dInputSignalOffset=2.5
nInputSignalPointCount = round(dSimulationDurationReal/dSimulationStep)
arrInputSignalX = np.linspace(0, dSimulationDurationReal, nInputSignalPointCount, endpoint=False)
arrInputSignalY = scipy.signal.square((2 * np.pi * dInputSignalFreq * arrInputSignalX + dInputSignalPhase - dSimulationPaddingAtStart), duty=dInputSignalDuty)
arrInputSignalY = dInputSignalAmplitude * arrInputSignalY + dInputSignalOffset

# Run simulation
# Results is an instance of pandas.DataFrame, whose columns are output channels, indexes are time points
# Use the "inputs" parameter to specify input signal
# Use the "outputs" parameter to specify output channels, you can access them with [ChannelName] index
#     Only "output" variables defined in OperatorTemplate can be measured
# See https://pyrates.readthedocs.io/en/latest/frontend.template.html#pyrates.frontend.template.circuit.CircuitTemplate.run
dctSimResults = jrcDemoJRC.run(
    simulation_time=dSimulationDurationReal,
    step_size=dSimulationStep,
    sampling_step_size=dSamplingStep,
    inputs={
        # Stimulating PC of JRC2, input to operator PRO, variable V
        "JRC2/PC/PRO/V" : arrInputSignalY,
        # Spontaneous electrical activities (spontaneous firing rate) are inputted to m_in port of PC's RPO_e operator
        "JRC1/PC/RPO_e/m_in" : np.array([220 for i in range(0,nInputSignalPointCount)]),
        "JRC2/PC/RPO_e/m_in" : np.array([220 for i in range(0,nInputSignalPointCount)]),
    },
    outputs={
        # Record from subnode PC, operator RPO_e (EIN output), variable V
        "JRC1_PC_e" : "JRC1/PC/RPO_e/V",
        # Record from subnode PC, operator RPO_i (IIN output), variable V
        "JRC1_PC_i" : "JRC1/PC/RPO_i/V"
    },
    clear=True
)
# Clear PyRates global caches
pyrates.utility.clear_frontend_caches()
[[/code]]

需要注意的是，PyRates生成的仿真结果中，共包含{{nPoint = simulation_time * (1.0 / sampling_step_size)}}个测量点。因此，部分算法（例如MNE工具包采用的算法：{{dTime = (nPoint - 1) * sampling_step_size}}）会导致测得的时长略小于{{simulation_time}}的设置值。此时，可以通过将{{simulation_time}}设为期望的仿真时长与1个{{sampling_step_size}}的和进行处理，即设置{{simulation_time=dSimulationDuration+dSamplingStep}}。

为了获得较为稳定的仿真结果，可以考虑在{{simulation_time}}中设置一个10 s左右的引导段，并在处理时剔除这个引导段：

[[code type="python"]]
# Remove simulation padding segment
iSimulationValidDataStartIndex = dSimulationPaddingAtStart / dSamplingStep
iSimulationValidDataStartIndex = round(dSimulationPaddingAtStart / dSamplingStep)
arrSimulationDataIndexesToDrop = list(range(0, iSimulationValidDataStartIndex))
arrSimulationDataTimePointsToDrop = [i*dSamplingStep for i in arrSimulationDataIndexesToDrop]
dctSimResults = dctSimResults.drop(labels=arrSimulationDataTimePointsToDrop, axis=0)
dctSimResults = dctSimResults.reset_index(drop=True)
arrSimualtionDataNewIndex = [i*dSamplingStep for i in dctSimResults.index]
dctSimResults.index = arrSimualtionDataNewIndex
[[/code]]

由于来自同一环路的EIN和IIN的电位被分开测量，因此可以使用加法对其进行合并：

[[code type="python"]]
import pandas as pd

# Merging results from EIN and IIN
dctSimResultsMerged = pd.DataFrame()
for CurrentKey in dctSimResults.keys() :
    # Check if current key is from a "XXX_e" and "XXX_i" pair
    if str(CurrentKey).endswith("_e") :
        # If curren key is an EIN output
        sCurrentKeyBase = str(CurrentKey).removesuffix("_e") 
        # Dertermin key of paired IIN output
        sCurrentKeyPaired = sCurrentKeyBase + "_i"
        if sCurrentKeyPaired in dctSimResults.keys() :
            # Merging key pairs, a simple "plus" operator is used
            # See https://pyrates.readthedocs.io/en/latest/auto_implementations/python_definitions.html
            dctSimResultsMerged[sCurrentKeyBase] = dctSimResults[sCurrentKeyBase + "_e"] + dctSimResults[sCurrentKeyBase + "_i"]
        else :
            # If we can't find a paired IIN output, log this entry directly
            dctSimResultsMerged[CurrentKey] = dctSimResults[CurrentKey]
        #End If 
    elif str(CurrentKey).endswith("_i") :
        # If curren key is an IIN output
        sCurrentKeyBase = str(CurrentKey).removesuffix("_i") 
        # Dertermin key of paired EIN output
        sCurrentKeyPaired = sCurrentKeyBase + "_e"
        if sCurrentKeyPaired in dctSimResults.keys() :
            # Since EIN output is handled in previous If branch, simply continuing the loop
            continue
        else :
            # If we can't find a paired EIN output, log this entry directly
            dctSimResultsMerged[CurrentKey] = dctSimResults[CurrentKey]
        #End If
    else :
        # For entries with other suffixes, log this entry directly
        dctSimResultsMerged[CurrentKey] = dctSimResults[CurrentKey]
    #End If
#Next
[[/code]]

仿真结果被存储为{{[*https://pandas.pydata.org/pandas-docs/stable/reference/frame.html pandas.Dataframe]}}对象的实例，其数据列（Columns）为输出键名，数据索引（Indexes）为数据对应的时间点。您可以通过{{run()}}函数的{{outputs}}中指定的键名访问仿真过程中获得的采样数据。

[[code type="python"]]
import matplotlib.pyplot as plt

# Plotting data
for CurrentChannel in dctSimResultsMerged.keys() :
    if (CurrentChannel+"_e") in dctSimResults.keys() :
        plt.plot(dctSimResults[CurrentChannel+"_e"], label=CurrentChannel+"_e")
    #End If
    if (CurrentChannel+"_i") in dctSimResults.keys() :
        plt.plot(dctSimResults[CurrentChannel+"_i"], label=CurrentChannel+"_i")
    #End If
    plt.plot(dctSimResultsMerged[CurrentChannel], label=CurrentChannel)
    plt.title(CurrentChannel)
    plt.legend()
    plt.show()
#Next

# Exporting data
dctSimResultsMerged.to_csv("SimResults.csv", index=False)
[[/code]]

+ 杂项

++ 缓存文件问题

PyRates默认会在当前工作目录（通过{{os.getcwd()}}获取）下建立缓存文件（如{{pyrates_run.py}}），若需要并行执行多个PyRates仿真，可能需要动态调整工作目录，例如：

[[code type="python"]]
# Change working directory to avoid pyrates_run.py confliction
import os
import shutil
import uuid
sSimulatorCacheDir = "temp/sim/"
sPreviousWorkDir = os.getcwd()
sCurrentSimulatorCacheDir = sSimulatorCacheDir + str(uuid.uuid4()) + "/"
os.makedirs(sCurrentSimulatorCacheDir, exist_ok=True)
os.chdir(sCurrentSimulatorCacheDir)

# Running simulation
jrcModel.run(...)

# Revert working directory
os.chdir(sPreviousWorkDir)
shutil.rmtree(sCurrentSimulatorCacheDir, ignore_errors=True)
[[/code]]

+ 参考资料

*https://pyrates.readthedocs.io/en/latest/auto_implementations/python_definitions.html

*https://pyrates.readthedocs.io/en/latest/auto_introductions/jansenrit.html